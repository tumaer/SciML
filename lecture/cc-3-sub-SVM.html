
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Support Vector Machines &#8212; Introduction to Scientific Machine Learning for Engineers</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Gaussian Processes" href="cc-3-sub-GP.html" />
    <link rel="prev" title="Core Content 3: Classic ML" href="cc-3-classic-ml.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Introduction to Scientific Machine Learning for Engineers</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../about.html">
                    About this Lecture
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Lecture
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="preliminaries.html">
   Preliminaries
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="motivation.html">
   Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cc-1-linear.html">
   Core Content 1: Linear Models
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cc-2-optimization.html">
   Core Content 2: Optimization
  </a>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="cc-3-classic-ml.html">
   Core Content 3: Classic ML
  </a>
  <input checked class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Support Vector Machines
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="cc-3-sub-GP.html">
     Gaussian Processes
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="cc-4-dl.html">
   Core Content 4: Deep Learning
  </a>
  <input checked class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="cc-4-gradients.html">
     Gradients
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="cc-4-sub-MLP.html">
     Multilayer Perceptron
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="cc-4-sub-CNN.html">
     Convolutional Neural Network
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="cc-4-rnn.html">
     Recurrent Models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="cc-4-ae.html">
     Encoder-Decoder Models: Aa Focus on the Necessary
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Exercise
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../exercise/1_linReg_logReg.html">
   1. Linear Regression and Logistic Regression
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../exercise/2_BayesianInference.html">
   2. Bayesian Linear and Logistic Regression
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../exercise/3_optimization.html">
   3. Optimization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../exercise/4_SVM.html">
   4. Support Vector Machines
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../exercise/5_GPs.html">
   5. Gaussian Processes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../exercise/6_CNNs.html">
   6. CNNs
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Miscellaneous
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../admin.html">
   Admin
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../books.html">
   Books
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../preliminary_knowledge.html">
   Preliminary Knowledge
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../software.html">
   Software Infrastructure
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../faq.html">
   Frequently Asked Questions
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/arturtoshev/SciML22-23"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/arturtoshev/SciML22-23/issues/new?title=Issue%20on%20page%20%2Flecture/cc-3-sub-SVM.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../_sources/lecture/cc-3-sub-SVM.md"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.md</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-constrained-optimization-problem">
   The Constrained Optimization Problem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#linearly-separable-sets-maximum-margin-classifier-mmc">
   Linearly Separable Sets - Maximum Margin Classifier (MMC)
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#non-separable-sets-soft-margin-classifier-smc">
   Non-Separable Sets - Soft Margin Classifier (SMC)
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#sequential-minimal-optimization-smo">
   Sequential Minimal Optimization (SMO)
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#coordinate-ascent">
     Coordinate Ascent
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#outline-of-smo-for-svm">
     Outline of SMO for SVM
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#kernel-methods">
   Kernel Methods
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#dual-representations">
     Dual representations
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#construction-of-suitable-kernels">
     Construction of suitable kernels
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#recapitulation-of-svms">
   Recapitulation of SVMs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#further-references">
   Further References
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Support Vector Machines</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-constrained-optimization-problem">
   The Constrained Optimization Problem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#linearly-separable-sets-maximum-margin-classifier-mmc">
   Linearly Separable Sets - Maximum Margin Classifier (MMC)
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#non-separable-sets-soft-margin-classifier-smc">
   Non-Separable Sets - Soft Margin Classifier (SMC)
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#sequential-minimal-optimization-smo">
   Sequential Minimal Optimization (SMO)
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#coordinate-ascent">
     Coordinate Ascent
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#outline-of-smo-for-svm">
     Outline of SMO for SVM
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#kernel-methods">
   Kernel Methods
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#dual-representations">
     Dual representations
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#construction-of-suitable-kernels">
     Construction of suitable kernels
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#recapitulation-of-svms">
   Recapitulation of SVMs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#further-references">
   Further References
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="support-vector-machines">
<h1>Support Vector Machines<a class="headerlink" href="#support-vector-machines" title="Permalink to this headline">#</a></h1>
<p>First, we need some mathematical formalism to solve constrained optimization problems.</p>
<section id="the-constrained-optimization-problem">
<h2>The Constrained Optimization Problem<a class="headerlink" href="#the-constrained-optimization-problem" title="Permalink to this headline">#</a></h2>
<p>If we define our optimization problem as:</p>
<div class="math notranslate nohighlight">
\[\underset{\omega}{\min} f(\omega) \quad \text{s.t.} \hspace{2pt} h_{i}(\omega)=0, \hspace{2pt} i=1, \ldots, l\]</div>
<p>Where the <span class="math notranslate nohighlight">\(\underset{\omega}{\min}\)</span> seeks to find the minimum subject to the constraint(s) <span class="math notranslate nohighlight">\(h_{i}(\omega)\)</span>. To solve this we have to define a Lagrangian to take into account the constraints.</p>
<div class="math notranslate nohighlight">
\[\mathcal{L}(\omega, \beta) = f(\omega) + \sum_{i=1}^{l} \beta_{i} h_{i}(\omega)\]</div>
<p>The <span class="math notranslate nohighlight">\(\beta_{i}\)</span> are the <em>Lagrangian multipliers</em>, which need to be identified to find the constraint-satisfying <span class="math notranslate nohighlight">\(\omega\)</span>. The necessary condition to solve this problem for the optimum is to solve</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    \frac{\partial \mathcal{L}}{\partial \omega_{i}} &amp;= 0 \\
    \frac{\partial \mathcal{L}}{\partial \beta_{i}} &amp;= 0
\end{aligned}\end{split}\]</div>
<p>for <span class="math notranslate nohighlight">\(\omega\)</span>, and <span class="math notranslate nohighlight">\(\beta\)</span>. In classification problems, we do not only have <em>equality constraints</em> as above but can also encounter <em>inequality constraints</em>. We formulate the primal optimization problem as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\underset{\omega}{\min} f(\omega) \text{ s.t.} \begin{cases} &amp;g_{i}(\omega) \leq 0, \quad i=1, \ldots, k \\
                    &amp;h_{j}(\omega) = 0, \quad j=1, \ldots, l
       \end{cases}\end{split}\]</div>
<p>To then define the generalized Lagrangian</p>
<div class="math notranslate nohighlight">
\[\mathcal{L}(\omega, \alpha, \beta) = f(\omega) + \sum_{i=1}^{k} \alpha_{i} g_{i}(\omega) + \sum_{j=1}^{l} \beta_{i} h_{j}(\omega)\]</div>
<p>and its corresponding optimization problem</p>
<div class="math notranslate nohighlight">
\[
\theta_{p}(\omega) = \underset{\alpha_{i} \geq 0, \beta_{j}}{\max} \mathcal{L}(\omega, \alpha, \beta).
\]</div>
<p>Now we can verify that this optimization problem satisfies</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\theta_{p}(\omega) = \begin{cases} &amp;f(\omega), \quad \text{if } \omega \text{ satisfies the primal constraints} \\
&amp;\infty, \quad \text{otherwise}
\end{cases}
\end{split}\]</div>
<p>Where does this case-by-case breakdown come from?</p>
<ol class="simple">
<li><p>In the first case, the constraints are inactive and contribute nil to the sum.</p></li>
<li><p>In the second case, the sums increase linearly with <span class="math notranslate nohighlight">\(\alpha_{i}\)</span>, <span class="math notranslate nohighlight">\(\beta_{i}\)</span> beyond all bounds.</p></li>
</ol>
<div class="math notranslate nohighlight">
\[
\Longrightarrow p^{\star} = \underset{\omega}{\min} \hspace{2pt} \theta_{p}(\omega) = \underset{\omega}{\min} \hspace{2pt} \underset{\alpha_{i} \geq 0, \beta_{j}}{\max} \mathcal{L}(\omega, \alpha, \beta)
\]</div>
<p>i.e. we recover the original primal problem with <span class="math notranslate nohighlight">\(p^{\star}\)</span> being the <em>value of the primal problem</em>. With this we can now formulate the <em>dual optimization problem</em>:</p>
<div class="math notranslate nohighlight">
\[
d^{\star} = \underset{\alpha_{i} \geq 0, \beta_{j}}{\max} \theta_{D}(\alpha, \beta) = \underset{\alpha_{i} \geq 0, \beta_{j}}{\max} \hspace{2pt} \underset{\omega}{\min} \hspace{2pt} \mathcal{L}(\omega, \alpha, \beta)
\]</div>
<p>with <span class="math notranslate nohighlight">\(\theta_{D}(\alpha, \beta) = \underset{\omega}{\min} \hspace{2pt} \mathcal{L}(\omega, \alpha, \beta)\)</span> and <span class="math notranslate nohighlight">\(d^{\star}\)</span> the value of the dual problem. Please note that the primal and dual problems correspond to each other, but exchange the order of minimization and maximization. To show this relation between min-max, and max-min we let <span class="math notranslate nohighlight">\(\mu(y) = \underset{x}{\inf} \hspace{2pt} \kappa(x, y)\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
    &amp;\Longrightarrow \mu(y) \leq \kappa(x, y) \\
    &amp;\Longrightarrow \underset{y}{\sup} \hspace{2pt} \mu(y) \leq \underset{y}{\sup} \hspace{2pt} \kappa(x, y) \\
    &amp;\Longrightarrow \underset{y}{\sup} \hspace{2pt} \mu(y) \leq \underset{x}{\inf} \hspace{2pt} \underset{y}{\sup} \hspace{2pt} \kappa(x, y) \\
    &amp;\Longrightarrow \underset{y}{\sup} \hspace{2pt} \underset{x}{\inf} \hspace{2pt} \kappa(x, y) \leq \underset{x}{\inf} \hspace{2pt} \underset{y}{\sup} \hspace{2pt} \kappa(x, y) \\
\end{aligned}
\end{split}\]</div>
<p>From the last line we can immediately imply the relation between the primal, and the dual problems:</p>
<div class="math notranslate nohighlight">
\[
d^{\star} = \underset{\alpha_{i} \geq 0, \beta_{j}}{\max} \hspace{2pt} \underset{\omega}{\min} \hspace{2pt} \mathcal{L}(\omega, \alpha, \beta) \leq \underset{\omega}{\min} \hspace{2pt} \underset{\alpha_{i} \geq 0, \beta_{j}}{\max} \hspace{2pt} \mathcal{L}(\omega, \alpha, \beta) = p^{\star}
\]</div>
<p>where the inequality can, under certain conditions, turn into equality. The conditions for this to turn into equality are the following (going back to the Lagrangian form from above):</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(f\)</span>, and <span class="math notranslate nohighlight">\(g_{i}\)</span> are convex, i.e. their Hessians are positive semi-definite. The exact definitions of the Hessians will be presented in 3 lectures.</p></li>
<li><p>The <span class="math notranslate nohighlight">\(h_{i}\)</span> are affine, i.e. they can be expressed as linear functions of their arguments.</p></li>
</ul>
<p>We hence have three conditions fulfilled</p>
<ol class="simple">
<li><p>The optimum solution <span class="math notranslate nohighlight">\(\omega^{\star}\)</span> to the primal optimization problem exists</p></li>
<li><p>The optimum solution <span class="math notranslate nohighlight">\(\alpha^{\star}\)</span>, <span class="math notranslate nohighlight">\(\beta^{\star}\)</span> to the dual optimization problem exists</p></li>
<li><p><span class="math notranslate nohighlight">\(\omega^{\star}\)</span>, <span class="math notranslate nohighlight">\(\alpha^{\star}\)</span>, and <span class="math notranslate nohighlight">\(\beta^{\star}\)</span> satisfy the Karush-Kuhn-Tucker (KKT) conditions.</p></li>
</ol>
<p>The KKT conditions are expressed as the following conditions</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
    \left. \frac{\partial \mathcal{L}(\omega, \alpha, \beta)}{\partial \omega_{i}} \right|_{\omega^{\star}, \alpha^{\star}, \beta^{\star}} &amp;= 0, \quad i=1, \ldots, n \qquad \text{(KKT1)}\\
    \left. \frac{\partial \mathcal{L}(\omega, \alpha, \beta)}{\partial \beta_{i}} \right|_{\omega^{\star}, \alpha^{\star}, \beta^{\star}} &amp;= 0, \quad i=1, \ldots, l \qquad \text{(KKT2)}
\end{aligned}
\end{split}\]</div>
<p>The KKT complementarity condition then amounts to</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
    \alpha_{i}^{\star} g_{i}(\omega^{\star}) &amp;= 0, \quad i=1, \ldots, k \qquad \text{(KKT3)}\\
    g_{i}(\omega^{\star}) &amp;\leq 0, \quad i=1, \ldots, k \qquad \text{(KKT4)}\\
    \alpha_{i}^{\star} &amp;\geq 0, \quad i=1, \ldots, k \qquad \text{(KKT5)}
\end{aligned}
\end{split}\]</div>
<p>Moreover, if a set <span class="math notranslate nohighlight">\(\omega^{\star}\)</span>, <span class="math notranslate nohighlight">\(\alpha^{\star}\)</span>, and <span class="math notranslate nohighlight">\(\beta^{\star}\)</span> satisfies the KKT conditions it is a solution to the primal/dual problem. The KKT conditions are sufficient and necessary here. The dual complementarity condition indicates whether the <span class="math notranslate nohighlight">\(g_{i}(\omega) \leq 0\)</span> constraint is active.</p>
<div class="math notranslate nohighlight">
\[
\alpha_{i}^{\star} &gt; 0 \Longrightarrow g_{i}(\omega^{\star}) = 0
\]</div>
<p>i.e. <span class="math notranslate nohighlight">\(\omega^{\star}\)</span> is “on the constraint boundary”.</p>
</section>
<section id="linearly-separable-sets-maximum-margin-classifier-mmc">
<h2>Linearly Separable Sets - Maximum Margin Classifier (MMC)<a class="headerlink" href="#linearly-separable-sets-maximum-margin-classifier-mmc" title="Permalink to this headline">#</a></h2>
<p>Alternative names for Maximum Margin Classifier (MMC) are Hard Margin Classifier and Large Margin Classifier.</p>
<p>Now, we can (re-)introduce the <em>linear discriminator</em>. Logistic regression <span class="math notranslate nohighlight">\(p(y=1| x; \theta)\)</span> is then modeled by <span class="math notranslate nohighlight">\(h(x) = g(\theta^{\top} x) = \text{sigm}(\theta^{\top} x)\)</span>:</p>
<div style="text-align:center">
    <img src="https://i.imgur.com/7VgPzdM.png" alt="drawing" width="400"/>
</div>
<p>If <span class="math notranslate nohighlight">\(g(\theta^{\top} x)\)</span> is then close to one, then we have large confidence that <span class="math notranslate nohighlight">\(x\)</span> belongs to class <span class="math notranslate nohighlight">\(\mathcal{C}_{1}\)</span> with <span class="math notranslate nohighlight">\(y=1\)</span>, whereas if it is close to <span class="math notranslate nohighlight">\(\frac{1}{2}\)</span>, we have much less confidence:</p>
<div style="text-align:center">
    <img src="https://i.imgur.com/4uZ08Td.png" alt="drawing" width="500"/>
</div>
<blockquote>
<div><p>The intuition here is that we seek to find the model parameters <span class="math notranslate nohighlight">\(\theta\)</span> such that <span class="math notranslate nohighlight">\(g(\theta^{\top}x)\)</span> maximizes the distance from the decision boundary <span class="math notranslate nohighlight">\(g(\theta^{\top}x) = \frac{1}{2}\)</span> for all data points.</p>
</div></blockquote>
<p>For consistency with the standard notation we slightly reformulate this problem setting:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
    y &amp;\in \{ -1, 1 \} \text{ as binary class labels} \\
    h(x) &amp;= g(\omega^{\top}x + b) \text{ as classifier with} \\
    g(z) &amp;= \begin{cases}
        1, \quad z \geq 0 \\
        -1, \quad \ &lt; 0
    \end{cases}
\end{align*}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\omega^{\top} x + b\)</span> defines a hyperplane for our linear classifier. With <span class="math notranslate nohighlight">\(b\)</span> we now make the bias explicit, where it was previously implicit in our expressions.</p>
<p><strong>Functional Margin</strong></p>
<p>The <em>functional margin</em> of <span class="math notranslate nohighlight">\((\omega, b)\)</span> w.r.t.  a single training sample then is:</p>
<div class="math notranslate nohighlight">
\[
\hat{\gamma}^{(i)} = y^{(i)}(\omega^{\top} x^{(i)} + b)
\]</div>
<p>For a confident prediction we would then like to have a maximum gap between the classes for a good classifier:</p>
<div style="text-align:center">
    <img src="https://i.imgur.com/eTkx5uU.png" alt="drawing" width="400"/>
</div>
<p>For correctly classified samples we always have</p>
<div class="math notranslate nohighlight">
\[
y^{(i)}(\omega^{\top} x^{(i)} + b) &gt; 0
\]</div>
<p>as <span class="math notranslate nohighlight">\(g(\omega^{\top}x + b) = y = \pm 1 \leftarrow \omega^{\top}x^{(i)} + b \geq 0\)</span>. Note that the induced functional margin is invariant to scaling:</p>
<div class="math notranslate nohighlight">
\[
g(\omega^{\top}x + b) = g(2\omega^{\top}x + 2b) = \ldots
\]</div>
<p>at times this may not be desirable as the classifier does not reflect that the margin itself is <strong>not</strong> invariant. For the entire set of training samples, we can also define the functional margin as</p>
<div class="math notranslate nohighlight">
\[
\hat{\gamma} = \underset{i}{\min} \hspace{2pt} \hat{\gamma}^{(i)}
\]</div>
<p><strong>Geometric Margin</strong></p>
<p>Now we can define the <em>geometric margin</em> with respect to a single sample <span class="math notranslate nohighlight">\(\gamma^{(i)}\)</span> as follows.</p>
<div style="text-align:center">
    <img src="https://i.imgur.com/UrEUiGA.png" alt="drawing" width="300"/>
</div>
<p>The distance <span class="math notranslate nohighlight">\(\gamma^{(i)}\)</span> of <span class="math notranslate nohighlight">\(x^{(i)}\)</span> from the decision boundary, i.e. from point P, is given by</p>
<div class="math notranslate nohighlight">
\[
\omega^{\top}\left(x^{(i)} - \gamma^{(i)} \frac{\omega}{||\omega||}\right) + b = 0
\]</div>
<p>where <span class="math notranslate nohighlight">\(x^{(i)} - \gamma^{(i)} \frac{\omega}{||\omega||}\)</span> gives the location of the point P, and <span class="math notranslate nohighlight">\(\frac{\omega}{||\omega||}\)</span> is the unit normal. As P is a member of the decision boundary, no matter where it is placed on the boundary, the equality always has to be <span class="math notranslate nohighlight">\(0\)</span> by definition.</p>
<div class="math notranslate nohighlight">
\[
\Longrightarrow \gamma^{(i)} = \left( \frac{\omega}{|| \omega ||} \right)^{\top} x^{(i)} + \frac{b}{||\omega||}.
\]</div>
<p>As this was for an example on the <span class="math notranslate nohighlight">\(+\)</span> side we can generalize said expression to obtain:</p>
<div class="math notranslate nohighlight">
\[
\gamma^{(i)} = y^{(i)} \left( \left(\frac{\omega}{|| \omega ||}\right)^{\top} x^{(i)} + \frac{b}{|| \omega ||} \right)
\]</div>
<p>Please note that the geometric margin indeed is <strong>scale invariant</strong>. For the entire set of samples, we can then define the geometric margin as:</p>
<div class="math notranslate nohighlight">
\[
\gamma = \underset{i}{\min} \gamma^{(i)}
\]</div>
<p><strong>Maximum Margin Classifier</strong></p>
<p>With these mathematical tools we are now ready to derive the <strong>Support Vector Machine (SVM)</strong> for linearly separable sets by maximizing the previously derived geometric margin:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\underset{\omega, b}{\max} \hspace{2pt} \gamma \quad \text{ s.t. } \begin{cases}
    &amp;y^{(i)} (\omega^{\top} x^{(i)} + b) \geq \gamma, \quad i=1, \ldots, m \\
    &amp;||\omega|| = 1 \Longrightarrow \hat{\gamma} = \gamma
\end{cases}
\end{split}\]</div>
<p>We then seek to reformulate to get rid of the non-convex <span class="math notranslate nohighlight">\(||\omega|| = 1\)</span> constraints:</p>
<div class="math notranslate nohighlight">
\[
\underset{\omega, b}{\max} \frac{\hat{\gamma}}{||\omega||} \quad \text{s.t. } y^{(i)}(\omega^{\top} x^{(i)} + b) \geq \gamma = \frac{\hat{\gamma}}{||\omega||}, \quad i=1, \ldots, m
\]</div>
<p>where we applied the definition of <span class="math notranslate nohighlight">\(\gamma = \frac{\hat{\gamma}}{||\omega||}\)</span>, but in the process suffered a setback as we now have a non-convex objective function. As the geometric margin <span class="math notranslate nohighlight">\(\gamma\)</span> is scale-invariant we can now simply scale <span class="math notranslate nohighlight">\(||\omega||\)</span> such that <span class="math notranslate nohighlight">\(\hat{\gamma} = \gamma ||\omega|| = 1\)</span>. Given <span class="math notranslate nohighlight">\(\hat{\gamma} = 1\)</span> it is clear that</p>
<div class="math notranslate nohighlight">
\[
\underset{\omega, b}{\max} \frac{\hat{\gamma}}{||\omega||} = \underset{\omega, b}{\max} \frac{1}{||\omega||},
\]</div>
<p>s.t. the constraints are satisfied, is the same as</p>
<div class="math notranslate nohighlight">
\[
\underset{\omega, b}{\min} ||\omega||^{2} 
\]</div>
<p>s.t. the constraints are satisfied. Which is now a convex objective.</p>
<blockquote>
<div><p>The Support Vector Machine is generated by the primal optimization problem.</p>
</div></blockquote>
<div class="math notranslate nohighlight">
\[
\underset{\omega, b}{\min} \frac{1}{2} ||\omega||^{2} \quad \text{s.t. } y^{(i)}\left( \omega^{\top} x^{(i)} + b \right) \geq 1, \quad i=1, \ldots, m
\]</div>
<p>or alternatively</p>
<div class="math notranslate nohighlight">
\[
\underset{\omega, b}{\min} \frac{1}{2} ||\omega||^{2} \quad \text{s.t. } g_{i}(\omega) = 1 - y^{(i)}\left( \omega^{\top} x^{(i)} + b \right) \leq 0, \quad i=1, \ldots, m
\]</div>
<p>Upon checking with the KKT dual complementarity condition, we see that <span class="math notranslate nohighlight">\(\alpha_{i} &gt; 0\)</span> only for samples with <span class="math notranslate nohighlight">\(\gamma_{i}=1\)</span>, i.e.</p>
<div style="text-align:center">
    <img src="https://i.imgur.com/T7dwj4d.png" alt="drawing" width="400"/>
</div>
<p>The 3 samples “-”, “-”, and “+” in the sketch are the only ones for which the KKT constraint is active.</p>
<blockquote>
<div><p>These are called the <strong>support vectors</strong>.</p>
</div></blockquote>
<p>From the sketch, we can already ascertain that the number of support vectors may be significantly smaller than the number of samples, i.e. also the number of active constraints that we have to take into account. Next, we construct the Lagrangian of the optimization problem:</p>
<div class="math notranslate nohighlight">
\[
\mathcal{L}(\omega, b, \alpha) = \frac{1}{2} ||\omega||^{2} - \sum_{i=1}^{m} \alpha_{i} \left[ y^{(i)} \left( \omega^{\top} x^{(i)} + b \right) -1 \right]
\]</div>
<blockquote>
<div><p>Note that in this case, our Lagrangian only has inequality constraints!</p>
</div></blockquote>
<p>We can then formulate the dual problem:</p>
<ol class="simple">
<li><p><span class="math notranslate nohighlight">\(\theta_{D}(\alpha) = \underset{\omega, b}{\min} \hspace{2pt} \mathcal{L}(\omega, b, \alpha)\)</span></p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
    \nabla_{\omega} \mathcal{L}(\omega, b, \alpha) &amp;= \omega - \sum_{i=1}^{m} \alpha_{i} y^{(i)} x^{(i)} = 0 \\
    \Longrightarrow \omega &amp;= \sum_{i=1}^{m} \alpha_{i} y^{(i)} x^{(i)} \\
    \Longrightarrow \frac{\partial \mathcal{L}}{\partial b} &amp;= \sum_{i=1}^{m} \alpha_{i} y^{(i)} = 0
\end{aligned}
\end{split}\]</div>
<p>Which we can then resubstitute into the original Lagrangian</p>
<div class="math notranslate nohighlight">
\[
\mathcal{L}(\omega, \alpha, \beta) = \frac{1}{2} ||\omega||^{2} - \sum_{i=1}^{m} \alpha_{i} \left[ y^{(i)} \left( \omega^{\top} x^{(i)} + b \right) - 1 \right]
\]</div>
<p>we now use</p>
<div class="math notranslate nohighlight">
\[
\sum_{i=1}^{m} \alpha_{i} y^{(i)} \omega^{\top} x^{(i)} = \omega^{\top} \sum_{i=1}^{m} \alpha_{i} y^{(i)}x^{(i)} = \omega^{\top} \omega = ||\omega||^{2}
\]</div>
<p>in the Lagrangian to arrive at</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
    &amp;= - \frac{1}{2} ||\omega||^{2} + \sum_{i=1}^{m} \alpha_{i} - b \sum_{i=1}^{m} \alpha_{i} y^{(i)} \\
    &amp;= \sum_{i=1}^{m} \alpha_{i} - \frac{1}{2} \sum_{i, j=1}^{m} y^{(i)}y^{(j)} \alpha_{i} \alpha_{j} x^{(i)^{\top}} x^{(j)} - b \sum_{i=1}^{m}\alpha_{i} y^{(i)}
\end{aligned}
\end{split}\]</div>
<p>The dual is then</p>
<div class="math notranslate nohighlight">
\[
\Longrightarrow \theta_{D}(\alpha) = \sum_{i=1}^{m} \alpha_{i} - \frac{1}{2} \sum_{i,j=1}^{m} y^{(i)} y^{(j)} \alpha_{i} \alpha_{j} x^{(i)^{\top}} x^{(j)}
\]</div>
<p>which we can then optimize as an optimization problem</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\underset{\alpha}{\max} \hspace{2pt} \theta_{D}(\alpha) \quad \text{s.t. } \begin{cases}
    &amp;\alpha_{i} \geq 0, \quad i=1, \ldots, m \\
    &amp;\sum_{i=1}^{m} \alpha_{i} y^{(i)} = 0
\end{cases}
\end{split}\]</div>
<p>The first constraint in this optimization problem singles out the support vectors, whereas the second constraint derives itself from our derivation of the dual of the Lagrangian (see above). The KKT conditions are then also satisfied</p>
<ul class="simple">
<li><p>The first KKT condition is satisfied as of our first step in the conversion to the Lagrangian dual.</p></li>
<li><p>The second KKT condition is not relevant.</p></li>
<li><p>The third KKT condition is satisfied with <span class="math notranslate nohighlight">\(\alpha_{i} &gt; 0 \Leftrightarrow y^{(i)}(\omega^{\top}x^{(i)} + b) = 0\)</span>, i.e. the support vectors, and <span class="math notranslate nohighlight">\(\alpha_{i}=0 \Leftrightarrow y^{(i)} (\omega^{\top} x^{(i)} + b) &lt; 1\)</span> for the others.</p></li>
<li><p>The fourth KKT condition <span class="math notranslate nohighlight">\(y^{(i)} (\omega^{\top} x^{(i)} + b) \leq 1\)</span> is satisfied by our construction of the Lagrangian.</p></li>
<li><p>The fifth KKT condition <span class="math notranslate nohighlight">\(\alpha_{i} \geq 0\)</span> is satisfied as of our dual optimization problem formulation.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
\Longrightarrow d^{\star} = p^{\star}, \text{ i.e. the dual problem solves the primal problem.}
\]</div>
<p>The two then play together in the following fashion:</p>
<ul class="simple">
<li><p>The dual problem gives <span class="math notranslate nohighlight">\(\alpha^{\star}\)</span></p></li>
<li><p>The primal problem gives <span class="math notranslate nohighlight">\(\omega^{\star}\)</span>, <span class="math notranslate nohighlight">\(b^{\star}\)</span>, with <span class="math notranslate nohighlight">\(b^{\star}\)</span> given by</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
b^{\star} = - \frac{\underset{i \in \mathcal{C}_{2}}{\max} \hspace{2pt} \omega^{\star^{\top}}x^{(i)} + \underset{j \in \mathcal{C}_{1}}{\min} \hspace{2pt} \omega^{\star^{\top}} x^{(j)}}{2}
\]</div>
<div style="text-align:center">
    <img src="https://i.imgur.com/hvW7yvx.png" alt="drawing" width="500"/>
</div>
<p>From the <span class="math notranslate nohighlight">\(x^{(i)}\)</span> on the negative margin one then gets to the decision boundary by <span class="math notranslate nohighlight">\(x^{(i)} + \omega^{\star}\)</span>, and from <span class="math notranslate nohighlight">\(x^{(j)}\)</span> on the positive margin by <span class="math notranslate nohighlight">\(x^{(j)} - \omega^{\star}\)</span>, i.e.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
    \Longrightarrow \underset{i \in \mathcal{C}_{2}}{\max} \hspace{2pt} \omega^{\star^{\top}} x^{(i)} + \omega^{\star^{\top}} \omega^{\star} + b^{\star} &amp;= 0 \\
    \underset{j \in \mathcal{C}_{1}}{\min} \hspace{2pt} \omega^{\star^\top} x^{(j)} - \omega^{\star^\top} \omega^{\star} + b^{\star} &amp;= 0
\end{aligned}
\end{split}\]</div>
<p>As <span class="math notranslate nohighlight">\(\omega^{\star^\top} \omega^{\star} = 1\)</span>, we can then solve for <span class="math notranslate nohighlight">\(b^{\star}\)</span></p>
<div class="math notranslate nohighlight">
\[
\Longrightarrow b^{\star} = - \frac{1}{2} \left( \underset{i \in \mathcal{C}_{2}}{\max} \hspace{2pt} \omega^{\star^{\top}} x^{(i)} + \underset{j \in \mathcal{C}_{1}}{\min} \hspace{2pt} \omega^{\star^\top} x^{(j)} \right)
\]</div>
<p>Now we can check how the SVM predicts <span class="math notranslate nohighlight">\(y\)</span> given <span class="math notranslate nohighlight">\(x\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
    \omega^{\star^{\top}}x + b^{\star} &amp;= \left( \sum_{i=1}^{m} \alpha_{i}^{\star} y^{(i)} x^{(i)} \right)^{\top} x + b \\
    &amp;= \sum_{i=1}^{m} \alpha_{i}^{\star} y^{(i)} \langle x^{(i)}, x \rangle + b
\end{aligned}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha_{i}\)</span> is only non-zero for support vectors and calls the inner product <span class="math notranslate nohighlight">\(\langle x^{(i)}, x \rangle\)</span> which is hence a highly efficient computation. As such we have derived the support vector machine for the linear classification of sets. The formulation of the optimum set-boundary/decision boundary was formulated as the search for a margin optimization, then transformed into a convex constrained optimization problem, before restricting the contributions of the computation to contributions coming from the <em>support vectors</em>, i.e., vectors on the actual decision boundary estimate hence leading to a strong reduction of the problem dimensionality.</p>
</section>
<section id="non-separable-sets-soft-margin-classifier-smc">
<h2>Non-Separable Sets - Soft Margin Classifier (SMC)<a class="headerlink" href="#non-separable-sets-soft-margin-classifier-smc" title="Permalink to this headline">#</a></h2>
<div style="text-align:center">
    <img src="https://i.imgur.com/PMZV7it.png" alt="drawing" width="500"/>
</div>
<p><em>Data may not be exactly linealy seperable or some data outliers may undesirably deform the exact decision boundary.</em></p>
<p><strong>Outlier problem</strong></p>
<div style="text-align:center">
    <img src="https://i.imgur.com/8s61hRD.png" alt="drawing" width="500"/>
</div>
<p><strong>Original SVM optimization problem</strong></p>
<div class="math notranslate nohighlight">
\[
\min _{\omega, b} \frac{1}{2}\|\omega\|^{2}  \quad \text {s.t. } y^{(i)}\left(\omega^{\top} x^{(i)}+b\right) \ge 1, i=1, \ldots, m
\]</div>
<p>To make the algorithm work for non-linearly separable data, we introduce <span class="math notranslate nohighlight">\(l_1\)</span>-regularization, i.e. a penalty term proportional to the magnitude of a certain quantity</p>
<p><span class="math notranslate nohighlight">\(\Rightarrow l_1\)</span>-regularised primal optimization problem</p>
<div class="math notranslate nohighlight">
\[
\min _{\omega, b} \frac{1}{2}\|\omega\|^{2}+C \sum_{i=1}^{m} \xi_{i}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\text{s.t.}\left\{\begin{array}{l}y^{(i)}\left(\omega^{\top} x^{(i)}+b\right) \geq 1-\xi_{i}, \quad i=1, \ldots, m \\ \xi_{i} \ge 0, \quad i=1, \ldots, \mathrm{m}\end{array}\right.\end{split}\]</div>
<p>Here, <span class="math notranslate nohighlight">\(\xi_i\)</span> is called a “slack” variable. We relax the previous requirement of a unit functional margin <span class="math notranslate nohighlight">\(\hat{\gamma}=1\)</span> by allowing some violation, which is penalized in the objective function.</p>
<ul class="simple">
<li><p>margin <span class="math notranslate nohighlight">\(\hat{\gamma}^{(i)}=1 - \xi_{i}, \quad \xi_{i}&gt;0\)</span></p></li>
<li><p>penalization <span class="math notranslate nohighlight">\(C\xi_{i}\)</span></p></li>
<li><p>parameter <span class="math notranslate nohighlight">\(C\)</span> controls the weight of the penalization</p></li>
</ul>
<p>Then, the Lagrangian of the penalized optimization problem becomes</p>
<p><span class="math notranslate nohighlight">\(\mathcal{L}(\omega, b, \xi, \alpha, \mu)=\frac{1}{2} \omega^{T} \omega+C \sum_{i=1}^{m} \xi_{i} -\sum_{i=1}^{m} \alpha_{i}\left[y^{(i)}\left(\omega^{\top} x^{(i)}+b\right)-1+\xi_{i}\right]-\sum_{i=1}^{m} \mu_{i} \xi_{i}.\)</span></p>
<p>In the above equation, the second term (<span class="math notranslate nohighlight">\(C \sum_{i=1}^{m} \xi_{i}\)</span>) represents the soft penalization of strict margin violation, whereas the third and fourth terms are the inequality constraints with Lagrangian multipliers <span class="math notranslate nohighlight">\(\alpha_{i}\)</span> and <span class="math notranslate nohighlight">\(\mu_{i}\)</span>. The derivation of the dual problem follows from the analogous steps of the non-regularised SVM problem.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
&amp;\frac{\partial \mathcal{L}}{\partial \omega} \stackrel{!}{=} 0  \quad \Rightarrow \quad w=\sum_{i=1}^{m} \alpha_{i} y^{(i)} x^{(i)}\\
&amp;\frac{\partial \mathcal{L}}{\partial b} \stackrel{!}{=} 0  \quad \Rightarrow \quad \sum_{i=1}^{m} \alpha_{i} y^{(i)}=0\\
&amp;\frac{\partial \mathcal{L}}{\partial \xi} \stackrel{!}{=} 0 \quad \Rightarrow \quad \alpha_{i}=C-\mu_i, \quad i=1, \ldots,m \qquad (\star)
\end{aligned}
\end{split}\]</div>
<p>The last equation arises from the additional condition due to slack variables. Upon inserting these conditions into <span class="math notranslate nohighlight">\(\mathcal{L}(\omega,b,\xi,\alpha,\mu)\)</span> we obtain the dual-problem Lagrangian:</p>
<div class="math notranslate nohighlight">
\[
\max_{\alpha} \theta_{D}(\alpha)=\max_{\alpha} \left( \sum_{i=1}^{m} \alpha_{i}-\frac{1}{2} \sum_{i,j=1}^{m} y^{(i)} y^{(j)} \alpha_{i} \alpha_{j}\left\langle x^{(i)}, x^{(j)}\right\rangle \right)
\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}
\text { s.t. }\left\{\begin{array}{l}
0 \leq \alpha_{i} \leq C, \quad i=1, \ldots, m \\
\sum_{i=1}^{m} \alpha_{i} y^{(i)}=0
\end{array}\right.
\end{split}\]</div>
<p>The “box constraints” (<span class="math notranslate nohighlight">\(0 \leq \alpha_{i} \leq C\)</span>) follow from the positivity requirement on Lagrange multipliers: <span class="math notranslate nohighlight">\(\alpha_{i}\ge 0,\mu_{i}\ge 0\)</span>.</p>
<p>Evaluating the KKT3-complementarity condition leads to</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
&amp;\alpha_{i}^{*} \left[y^{(i)}\left(\omega^{\top} x^{(i)}+b\right)-1+\xi_{i}\right]=0 \Leftrightarrow \begin{cases}\alpha_{i}^{*}&gt;0, &amp; y^{(i)}\left(\omega^{\top} x^{(i)}+b\right)=1-\xi_{i} \\ 
\alpha_{i}^{*}=0, &amp; y^{(i)}\left(\omega^{\top} x^{(i)}+b\right) \ge 1-\xi_{i} \end{cases}\\
&amp;\mu_{i}^{*} \xi_{i}=0 \Leftrightarrow \begin{cases}\mu_{i}^{*}&gt;0, &amp; \xi_{i}=0 \\ 
\mu_{i}^{*}=0, &amp; \xi_{i}&gt;0\end{cases}
\end{aligned}
\end{split}\]</div>
<p>The resulting dual complementarity conditions for determining the support vectors become:</p>
<ul class="simple">
<li><p>Support vectors on slack margin (<span class="math notranslate nohighlight">\(\alpha_i=0\)</span>, i.e. data point is ignored)</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
\alpha_{i}^{*}=0 \Rightarrow y^{(i)}\left(\omega^{\top} x^{(i)}+b\right) \ge 1
\]</div>
<ul class="simple">
<li><p>Support vectors inside or outside margin (<span class="math notranslate nohighlight">\(\alpha^*=C\)</span>, i.e. data point violates the MMC)</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
C=\alpha_{i}^{*} \quad &amp; (\star) \Rightarrow \mu_{i}^{*}=0,\left\{\begin{array}{rr}
0 &lt; \xi_{i} \leq 1 &amp; \text{(correctly classified)} \\ 
 \xi_{i}&gt;1 &amp; \text{(misclassified)}\end{array}\right.\\
&amp; \Rightarrow \quad y^{(i)}\left(\omega^{\top} x^{(i)}+b\right) &lt; 1
\end{aligned}\end{split}\]</div>
<ul class="simple">
<li><p>Support vectors on margin (<span class="math notranslate nohighlight">\(\alpha_i^*&gt;0\)</span> &amp; <span class="math notranslate nohighlight">\(\xi_i&gt;0\)</span>, i.e. data point on the margin)</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
0 &lt; \alpha_{i}^{*}&lt;C \quad &amp; (\star) \Rightarrow \mu_{i}^{*}&gt;0 \quad \Rightarrow \xi_{i}=0 \\
&amp;\Rightarrow \quad y^{(i)}\left(\omega^{\top} x^{(i)}+b\right)=1
\end{aligned}\end{split}\]</div>
<p>The optimum <span class="math notranslate nohighlight">\(b^*\)</span> is obtained from averaging over all support vectors: condition to be satisfied by <span class="math notranslate nohighlight">\(b^*\)</span> is given by SVs on the margin:</p>
<div class="math notranslate nohighlight">
\[0&lt;\alpha_{i}^{*}&lt;C \Rightarrow y^{(i)}\left(\omega^{\top} x^{(i)}+b\right)=1\]</div>
<p><span class="math notranslate nohighlight">\(\Rightarrow\)</span> for <span class="math notranslate nohighlight">\(b^*\)</span> we obtain the same result as for the linearly separable problem</p>
<div class="math notranslate nohighlight">
\[\omega^*=\sum_{i=1}^{m_{s}} \alpha_{i}^* y^{(i)} x^{(i)}, \quad m_{s} \text{ support vectors.}\]</div>
<div class="math notranslate nohighlight">
\[\Rightarrow y^{(i)}(\omega^* x^{(i)} + b^*) = 1.\]</div>
<p>A numerically stable option is to average over <span class="math notranslate nohighlight">\(m_{\Sigma}\)</span>, i.e. all SV on the margin satisfying <span class="math notranslate nohighlight">\(0&lt;\alpha_{i}^{*}&lt;C\)</span>:</p>
<div class="math notranslate nohighlight">
\[b^* = \frac{1}{m_{\Sigma}} \sum_{j=1}^{m_{\Sigma}}\left(y^{(j)}-\sum_{i=1}^{m_{\Sigma}} \alpha_{i}^{*} y^{(i)}\left\langle x^{(i)}, x^{(j)}\right\rangle\right)
\]</div>
<blockquote>
<div><p>Recall: only data with <span class="math notranslate nohighlight">\(\alpha_{i}^*\ne 0\)</span>, i.e. support vectors, will contribute to the SVM prediction (last eq. of Linearly Separable Sets).</p>
</div></blockquote>
<p>In conclusion, we illustrate the functionality of the slack variables.</p>
<div style="text-align:center">
    <img src="https://i.imgur.com/luacvXq.png" alt="drawing" width="500"/>
</div>
</section>
<section id="sequential-minimal-optimization-smo">
<h2>Sequential Minimal Optimization (SMO)<a class="headerlink" href="#sequential-minimal-optimization-smo" title="Permalink to this headline">#</a></h2>
<ul class="simple">
<li><p>Efficient algorithm for solving the SVM dual problem</p></li>
<li><p>Based on <em>Coordinate Ascent</em> algorithm.</p></li>
</ul>
<section id="coordinate-ascent">
<h3>Coordinate Ascent<a class="headerlink" href="#coordinate-ascent" title="Permalink to this headline">#</a></h3>
<ul class="simple">
<li><p>Task : find <span class="math notranslate nohighlight">\(\max _{x} f\left(x_{1}, \ldots, x_{m}\right)\)</span></p></li>
<li><p>Perform a component-wise search on <span class="math notranslate nohighlight">\(x\)</span></p></li>
</ul>
<p><em>Algorithm</em></p>
<p><strong>do until converged</strong> <br>
 <strong>for</strong> <span class="math notranslate nohighlight">\(i=1, \ldots, m\)</span> <br>
<span class="math notranslate nohighlight">\(\qquad x_{i}^{(k+1)}=\underset{\tilde{x}_{i}}{\operatorname{argmax} } f\left(x_{1}^{(k)}, \ldots, \tilde{x}_{i}, \ldots, x_{m}^{(k)}\right) \)</span> <br>
 <strong>end for</strong> <br>
<strong>end do</strong></p>
<p><em>Sketch of algorithm</em></p>
<div style="text-align:center">
    <img src="https://i.imgur.com/2mNIzO1.png" alt="drawing" width="500"/>
</div>
<p>Coordinate ascent converges for convex continuous functions but may not converge to the dual optimum!</p>
</section>
<section id="outline-of-smo-for-svm">
<h3>Outline of SMO for SVM<a class="headerlink" href="#outline-of-smo-for-svm" title="Permalink to this headline">#</a></h3>
<p>Task: solve SVM dual optimization problem</p>
<div class="math notranslate nohighlight">
\[
\max_{\alpha} \theta_{D}(\alpha)=\sum_{i=1}^{m} \alpha_{i}-\frac{1}{2} \sum_{i,j=1}^{m} y^{(i)} y^{(j)} \alpha_{i} \alpha_{j}\left\langle x^{(i)}, x^{(j)}\right\rangle
\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}
\text { s.t. }\left\{\begin{array}{l}
0 \leq \alpha_{i} \leq C, \quad i=1, \ldots, m \\
\sum_{i=1}^{m} \alpha_{i} y^{(i)}=0
\end{array}\right.
\end{split}\]</div>
<p>Consider now an iterative update for finding the optimum:</p>
<ul class="simple">
<li><p>Iteration step delivers a constraint satisfying set of <span class="math notranslate nohighlight">\(\alpha_{i}\)</span>.</p></li>
<li><p>Can we just change some <span class="math notranslate nohighlight">\(\alpha_{j} \epsilon\)</span> {<span class="math notranslate nohighlight">\(\alpha_{1}\)</span>,….,<span class="math notranslate nohighlight">\(\alpha_{m}\)</span>} according to coordinate ascent for finding the next iteration update?</p>
<ul>
<li><p>No, because <span class="math notranslate nohighlight">\(\sum_{i=1}^{m} \alpha_{i}y^{(i)}=0\)</span> constrains the sum of all <span class="math notranslate nohighlight">\(\alpha_{i}\)</span>, and varying only a single <span class="math notranslate nohighlight">\(\alpha_{p}\)</span> may lead to constraint violation</p></li>
</ul>
</li>
<li><p>Fix it by changing a pair of <span class="math notranslate nohighlight">\(\alpha_{p},\alpha_{q}\)</span> , <span class="math notranslate nohighlight">\(p\ne q\)</span> , simultaneously.</p></li>
</ul>
<p><span class="math notranslate nohighlight">\(\Rightarrow\)</span> the SMO algorithm.</p>
<p><em>Algorithm</em></p>
<p><strong>do until convergence criterion satisfied</strong></p>
<ol class="simple">
<li><p>Given <span class="math notranslate nohighlight">\(\alpha^{(k)}\)</span> constraint satisfying</p></li>
<li><p>Select <span class="math notranslate nohighlight">\(\alpha_{p}^{(k+1)}=\alpha_{p}^{(k)}, \; \alpha_{q}^{(k+1)}=\alpha_{q}^{(k)}\)</span> for <span class="math notranslate nohighlight">\(p \ne q\)</span> following some estimate which <span class="math notranslate nohighlight">\(p,q\)</span> will give fastest ascent</p></li>
<li><p>Find <span class="math notranslate nohighlight">\(\left(\alpha_{p}^{(k+1)}, \alpha_{q}^{(k+1)}\right)=\underset{\alpha_{p},\alpha_{q}}{\operatorname{argmax} } \theta_{D}\left(x_{1}^{(k)}, \ldots, \alpha_{p},  \ldots,\alpha_{q}, \ldots, x_{m}^{(k)}\right)\)</span>
// except for <span class="math notranslate nohighlight">\(\alpha_{p},\alpha_{q}\)</span> all others are kept fixed.</p></li>
</ol>
<p><strong>end do</strong></p>
<p>Convergence criterion for SMO: check whether KKT conditions are satisfied up to a chosen tolerance.</p>
<p><strong>Discussion of SMO</strong></p>
<ul class="simple">
<li><p>assume <span class="math notranslate nohighlight">\(\alpha^{(k)}\)</span> given with <span class="math notranslate nohighlight">\(\sum_{i=1}^{m} y^{(i)}  \alpha^{(k)}_{i}=0\)</span></p></li>
<li><p>pick <span class="math notranslate nohighlight">\(\alpha_{1}=\alpha^{(k)}_1\)</span> and  <span class="math notranslate nohighlight">\(\alpha_2=\alpha^{(k)}_2\)</span> for optimization</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
\Rightarrow \alpha_{1} y^{(1)}+\alpha_{2} y^{(2)}=-\sum_{i=3}^{m} \alpha_{i} y^{(i)}=\rho \quad
\]</div>
<p>Note that the r.h.s. is constant during the current iteration step.</p>
<div style="text-align:center">
    <img src="https://i.imgur.com/Pk0o5BN.png" alt="drawing" width="500"/>
</div>
<p>The box constraints imply <span class="math notranslate nohighlight">\(L \le \alpha_{2} \le H\)</span>. Note that depending on the slope of the line, L or H may be clipped by the box constraint.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
&amp;\alpha_{1} y^{(1)}+\alpha_{2} y^{(2)}=\rho \\
&amp;\Rightarrow \alpha_{1}=\left(\rho-\alpha_{2} y^{(2)}\right) y^{(1)}
\end{aligned}
\end{split}\]</div>
<p><span class="math notranslate nohighlight">\(\rightarrow\)</span> Do you see what happened here?</p>
<p>Answer:</p>
<p><span class="math notranslate nohighlight">\(\alpha_{1} y^{(1)}+\alpha_{2} y^{(2)}=\rho \quad / \cdot y^{(1)}\)</span></p>
<p><span class="math notranslate nohighlight">\(\Rightarrow \alpha_{1} y^{(1)^2}=\left(\rho-\alpha_{2} y^{(2)}\right) y^{(1)}\)</span></p>
<p><span class="math notranslate nohighlight">\(y^{(1)^2}=1,\)</span> as <span class="math notranslate nohighlight">\(y \in\{-1,1\}\)</span></p>
<div class="math notranslate nohighlight">
\[\Rightarrow \theta_{D}(\alpha)=\sum_{i=1}^{m} \alpha_{i}-\frac{1}{2} \sum_{i,j=1}^{m} y^{(i)} y^{(j)} \alpha_{i} \alpha_{j}\left\langle x^{(i)}, x^{(j)}\right\rangle\]</div>
<p><em>with <span class="math notranslate nohighlight">\(\alpha_{1}=\left(\rho-\alpha_{2} y^{(2)}\right) y^{(1)}\)</span> thus becomes a quadratic function of <span class="math notranslate nohighlight">\(\alpha_2\)</span> , as all other <span class="math notranslate nohighlight">\(\alpha_{j\ne 1,2}\)</span> are fixed.</em></p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\theta_D(\alpha_2)=A\alpha^2_2+B\alpha_2+const.\)</span>
can be solved for <span class="math notranslate nohighlight">\(arg\max_{\alpha_2}\theta_{D}(\alpha_2)=\alpha_2^{'}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\alpha_2^{'}\rightarrow\)</span> box constraints <span class="math notranslate nohighlight">\(\rightarrow \alpha_2^{''}\)</span></p></li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}\alpha_2^{''} = \left\{\begin{array}{l}
H , \quad \alpha_{2}^{'}&gt;H \\
\alpha_{2}^{'} , \quad L \leq \alpha_{2}^{'} \leq H\\
L, \quad \alpha_{2}^{'}&lt;L
\end{array}\right.\end{split}\]</div>
<ul class="simple">
<li><p>set <span class="math notranslate nohighlight">\(\alpha_2^{(k+1)} = \alpha_2^{''}\)</span></p></li>
</ul>
<div class="math notranslate nohighlight">
\[
\alpha_{1}^{(k+1)}=\left(\rho-\alpha_{2}^{(k+1)} y^{(2)}\right) y^{(1)}
\]</div>
<ul class="simple">
<li><p>next iteration update</p></li>
</ul>
</section>
</section>
<section id="kernel-methods">
<h2>Kernel Methods<a class="headerlink" href="#kernel-methods" title="Permalink to this headline">#</a></h2>
<p>Consider binary classification in the non-linearly-separable case:</p>
<div style="text-align:center">
    <img src="https://i.imgur.com/uWMk3qq.png" alt="drawing" width="600"/>
</div>
<br>
<p><em>Kernel trick</em> or kernel substitution :</p>
<div class="math notranslate nohighlight">
\[x\rightarrow\varphi(x)\]</div>
<ul class="simple">
<li><p><em>in general <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(\varphi\)</span> are vectors where <span class="math notranslate nohighlight">\(\varphi\)</span> has the entire <span class="math notranslate nohighlight">\(x\)</span> as argument</em></p></li>
</ul>
<p><span class="math notranslate nohighlight">\(\Rightarrow\)</span> modified classifyer</p>
<div class="math notranslate nohighlight">
\[h(x)= g(\omega^T \varphi(x)+b)\]</div>
<p><em>e.g. such that the above problem becomes linearly separable</em></p>
<p><strong>Example</strong></p>
<div style="text-align:center">
    <img src="https://i.imgur.com/qo0P4Yz.png" alt="drawing" width="300"/>
</div>
<p>This classification problem is non-linear as there is no linear decision boundary.</p>
<p>Define feature map <span class="math notranslate nohighlight">\(\varphi (x_1,x_2) = x_1 x_2\)</span>  (<em>maps 2D <span class="math notranslate nohighlight">\(\rightarrow\)</span> 1D</em>)</p>
<div style="text-align:center">
    <img src="https://i.imgur.com/y55rIlC.png" alt="drawing" width="600"/>
</div>
<p>But of course, this is constructed, as then we could immediately guess <span class="math notranslate nohighlight">\(\varphi(x_1,x_2)\)</span>. In general, this is not possible.</p>
<blockquote>
<div><p>Recall : the dual problem of SVM involves a scalar product <span class="math notranslate nohighlight">\(x^{(i)T}x^{(j)}\)</span> of feature vectors.
<span class="math notranslate nohighlight">\(\Rightarrow\)</span> motivates the general notation of a dual problem with feature maps.</p>
</div></blockquote>
<section id="dual-representations">
<h3>Dual representations<a class="headerlink" href="#dual-representations" title="Permalink to this headline">#</a></h3>
<p>Motivated by Least Mean Squares (LMS) regression, we consider the following <strong>regularized</strong> cost function:</p>
<div class="math notranslate nohighlight">
\[
J(\omega)=\sum_{i=1}^{m}\left(w^{T} \varphi\left(x^{(i)}\right)-y^{(i)}\right)^{2}+\frac{\lambda}{2} \omega^{T} \omega
\]</div>
<p>with penalty parameter <span class="math notranslate nohighlight">\(\lambda \geqslant 0\)</span>.</p>
<blockquote>
<div><p>Notation alert: in Core Content 1 we used <span class="math notranslate nohighlight">\(\vartheta\)</span> for the parameters instead of the <span class="math notranslate nohighlight">\(\omega\)</span> used here.</p>
</div></blockquote>
<p>Regularization helps to suppress the overfitting problem (see Core Content 2). The squared L2 regularization above is also called <strong>Tikhonov regularization</strong>.  In machine learning, linear regression in combination with Tikhonov regularization is often dubbed <strong>ridge regression</strong>.</p>
<div class="math notranslate nohighlight">
\[\nabla_{\omega}J=0\]</div>
<div class="math notranslate nohighlight">
\[\Rightarrow \omega = -\frac{1}{\lambda} \sum_{i=1}^{m}\left(w^{T} \varphi\left(x^{(i)}\right)-y^{(i)}\right)\varphi(x^{(j)})=\Phi^Ta\]</div>
<p>with design matrix <span class="math notranslate nohighlight">\(\Phi\)</span> with feature map <span class="math notranslate nohighlight">\(\varphi\)</span> defined as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\Phi=\left[\begin{array}{c}\vdots \\ \varphi\left(x^{(j)}\right) \\ \vdots\end{array}\right] \in \mathbb{R}^{m \times n}\end{split}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\begin{split}a = -\frac{1}{\lambda} \left[\begin{array}{c}\vdots \\ w^{T} \varphi\left(x^{(i)}\right)-y^{(i)} \\ \vdots\end{array}\right] \in \mathbb{R}^m\end{split}\]</div>
<p>Substituting the necessary condition  <span class="math notranslate nohighlight">\(\omega = \Phi^Ta\)</span> into <span class="math notranslate nohighlight">\(J(\omega)\)</span> we obtain the dual problem:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned} J_{D}(a)=&amp; \frac{1}{2} a^T \Phi \Phi^T \Phi \Phi^Ta -a^T \Phi \Phi^T y+\frac{1}{2} y^T y+\frac{\lambda}{2} a^T \Phi \Phi^Ta \\=&amp; \frac{1}{2} a^T K K a-a^T K y+\frac{1}{2} y^T y+\frac{\lambda}{2} a^T Ka \end{aligned}\end{split}\]</div>
<p>Here, <span class="math notranslate nohighlight">\(K=\Phi\Phi^T\)</span> is a <strong>Grammatrix</strong> generated by a vector <span class="math notranslate nohighlight">\(\varphi\)</span> according to <span class="math notranslate nohighlight">\(K_{ij} = \langle \varphi_i , \varphi_j \rangle\)</span> where <span class="math notranslate nohighlight">\(\langle \cdot , \cdot \rangle\)</span> is an inner product - here <span class="math notranslate nohighlight">\(\langle \varphi(x^{(i)}),\varphi(x^{(j)}) \rangle\)</span>.</p>
<div class="math notranslate nohighlight">
\[K_{ij} = \varphi^T(x^{(i)})\varphi(x^{(j)}) =: K(x^{(i)},x^{(j)})\]</div>
<p>where <span class="math notranslate nohighlight">\(K(x^{(i)},x^{(j)})\)</span> is the <strong>kernel function</strong>.</p>
<p>Now we find that we can express the LMS prediction in terms of the kernel function:</p>
<div class="math notranslate nohighlight">
\[J_{D}(a)=\frac{1}{2} a^{T} K K a-a^T K y-\frac{1}{2} y^{T} y+\frac{\lambda}{2} a^T K a\]</div>
<p>In order to find <span class="math notranslate nohighlight">\(\max_{a} J_D (a)\)</span> we set <span class="math notranslate nohighlight">\(\nabla_a J_D (a) = 0\)</span></p>
<div class="math notranslate nohighlight">
\[\Rightarrow Ka - y + \lambda Ia = 0\]</div>
<div class="math notranslate nohighlight">
\[\Rightarrow a = (K+\lambda I)^{-1} y\]</div>
<p>Upon inserting this result into a linear regression model with feature mapping</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
h(x) &amp;= \omega^T \varphi (x) + b = a^T \Phi \varphi (x) = \Phi^T \varphi (x) a \\
&amp;=K^T (K+\lambda I)^{-1} y
\end{aligned}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(K_i = K(x^{(i)},x)\)</span> are the components of K.</p>
<p>Now, let’s do some bookkeeping</p>
<div class="math notranslate nohighlight">
\[\underbrace{a}_{M}=\underbrace{(K-\lambda I )^{-1}}_{M \times M} \underbrace{y}_{M}, \quad M = \text{number of data points}\]</div>
<blockquote>
<div><p>Recall from Class 2 <span class="math notranslate nohighlight">\(\underbrace{\vartheta}_{N}=\underbrace{(X^{T}X)^{-1}}_{N \times N} \underbrace{X^T}_{N \times M} \underbrace{y}_{M}, \quad N = \text{dim of input data vector}\)</span></p>
</div></blockquote>
<p>As typically <span class="math notranslate nohighlight">\(M&gt;&gt;N\)</span> we see that solving the dual problem for LMS requires us to invest a <span class="math notranslate nohighlight">\(MxM\)</span> matrix, whereas the primal problem tends only to a <span class="math notranslate nohighlight">\(NxN\)</span> matrix.</p>
<p>The benefit of the dual problem with the kernel <span class="math notranslate nohighlight">\(K(x,x')\)</span> is that now we can work with the kernel directly
<span class="math notranslate nohighlight">\(\Rightarrow\)</span> dimensionality of <span class="math notranslate nohighlight">\(\varphi(x)\)</span> matters no longer.
<span class="math notranslate nohighlight">\(\Rightarrow\)</span> we can consider even an infinite-dimensional feature vector <span class="math notranslate nohighlight">\(N \rightarrow \infty\)</span>, i.e. a continuous <span class="math notranslate nohighlight">\(\varphi (x)\)</span></p>
</section>
<section id="construction-of-suitable-kernels">
<h3>Construction of suitable kernels<a class="headerlink" href="#construction-of-suitable-kernels" title="Permalink to this headline">#</a></h3>
<ul class="simple">
<li><p>construction from feature map</p></li>
</ul>
<div class="math notranslate nohighlight">
\[ K(x,x') = \varphi^T (x) \varphi (x') = \sum_{i=1}^{N} \varphi_i (x) \varphi_i (x')\]</div>
<ul class="simple">
<li><p>direct construction with constraint that a <em>valid kernel</em> is obtained, i.e. it needs actually to correspond to a possible feature-map scalar product.</p></li>
</ul>
<p>A <strong>necessary and sufficient condition</strong> for a valid kernel is that <strong><span class="math notranslate nohighlight">\(K\)</span> is positive semidefinite for all <span class="math notranslate nohighlight">\(x\)</span></strong>.</p>
<p><strong>Examples (1)</strong></p>
<p>Given is <span class="math notranslate nohighlight">\(x, x' \in \mathbb{R}^N\)</span> and a scalar kernel</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
K(x,x') &amp; = (x^Tx')^2 \\
&amp; = \sum_{i=1}^N x_i x_i' \sum_{j=1}^N x_jx_j' \\
&amp; = \sum_i \sum_j x_ix_jx_i'x_j'.
\end{aligned}\end{split}\]</div>
<p>The corresponding feature map for</p>
<div class="math notranslate nohighlight">
\[K(x,x') = \varphi^T(x)\varphi(x')\]</div>
<p>for <span class="math notranslate nohighlight">\(N=3\)</span> is</p>
<div class="math notranslate nohighlight">
\[\begin{split}\varphi (x) = \left[\begin{array}{l} x_1 x_1 \\ x_1 x_2 \\ x_1 x_3 \\ x_2 x_1 \\ \ldots \\ x_3x_3 \end{array}\right] \end{split}\]</div>
<p><strong>Examples (2)</strong></p>
<p>Alternative kernel with parameter <span class="math notranslate nohighlight">\(c\)</span>:</p>
<div class="math notranslate nohighlight">
\[K(x,x') = (x^Tx'+c)^2 = \sum_{i,j} x_ix_jx_i'x_j' + \sum_i \sqrt{2c} x_i \sqrt{2c} x_j + c^2\]</div>
<p>belongs to</p>
<div class="math notranslate nohighlight">
\[\begin{split}\varphi(x)= \left[\begin{array}{l} x_1 x_1 \\ x_1 x_2 \\ \ldots \\ x_3x_3 \\ \sqrt{2c}x_1 \\ \sqrt{2c}x_2 \\ \sqrt{2c}x_3 \\ c  \end{array}\right]\end{split}\]</div>
<br>
<p>Considering that <span class="math notranslate nohighlight">\(\varphi(x)\)</span> and <span class="math notranslate nohighlight">\(\varphi(x')\)</span> are vectors, the scalar product <span class="math notranslate nohighlight">\(K(x,x')=\varphi^T(x)\varphi(x')\)</span> expresses the projection of <span class="math notranslate nohighlight">\(\varphi(x')\)</span> onto <span class="math notranslate nohighlight">\(\varphi(x)\)</span>.</p>
<p><span class="math notranslate nohighlight">\(\Rightarrow\)</span> the larger the kernel value, the more parallel the vectors are. Conversely, the smaller, the more orthogonal they are.</p>
<p><span class="math notranslate nohighlight">\(\Rightarrow\)</span> intuitively <span class="math notranslate nohighlight">\(K(x,x')\)</span> is a measure of “how close” <span class="math notranslate nohighlight">\(\varphi(x)\)</span> and <span class="math notranslate nohighlight">\(\varphi(x')\)</span> are.</p>
<p><strong>Example: Gaussian kernel</strong></p>
<div class="math notranslate nohighlight">
\[\begin{split}K(x,x')= \exp \left\{- \frac{(x-x')^T (x-x')}{2 \sigma^2} \right\} \\
\left\{\begin{array}{l} \approx 1 , \quad x \text{ and } x' \text{ close}  \\ \approx 0 , \quad x \text{ and } x' \text{ far apart} \end{array}\right.\end{split}\]</div>
<p>Now we show for illustration that a valid kernel is positive semidefinite, this is the above-mentioned necessary condition.</p>
<p><strong>Proof:</strong></p>
<div class="math notranslate nohighlight">
\[K_{ij} = \varphi^T(x^{(i)})\varphi(x^{(j)}) = \varphi^T(x^{(j)})\varphi(x^{(i)}) = K_{ji}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned} \Rightarrow (x')^TKx' &amp;= x'_i K_{ij}x'_j \\ 
&amp; = x'_i \varphi^T(x^{(i)}) \varphi(x^{(j)}) x'_j \\
&amp; = x'_i \varphi_k^{(i)} \varphi_k^{(j)} x'_j \\
&amp; = \sum_k (x_i^{(i)} \varphi_k^{(i)})^2 \geqslant 0 \end{aligned}\end{split}\]</div>
<p>The necessary and sufficient condition is due to <strong><a class="reference external" href="https://en.wikipedia.org/wiki/Mercer%27s_theorem">Mercer’s theorem</a></strong>:</p>
<p>A given <span class="math notranslate nohighlight">\(K: \mathbb{R}^N \times \mathbb{R}^N \rightarrow \mathbb{R}\)</span> is a valid kernel if for any {<span class="math notranslate nohighlight">\(x^{(1)},...,x^{(m)}\)</span>}, <span class="math notranslate nohighlight">\(m&lt;\infty\)</span> the resulting <span class="math notranslate nohighlight">\(K\)</span> is positive semidefinite (which implies that it also must be symmetric).</p>
<br>
<p>For non-separable sets we still can apply MMC or slack-variable SMC: We simply replace the feature-scalar product within the SVM prediction.</p>
<div class="math notranslate nohighlight">
\[h(x) = \omega^{*T}x+b^* = \sum_{i=1}^m \alpha_i^* y^{(i)} \langle x^{(i)} , x \rangle + b^*\]</div>
<p>We replace <span class="math notranslate nohighlight">\(\langle x^{(i)} , x \rangle\)</span> by <span class="math notranslate nohighlight">\(K(x^{(i)},x)\)</span>.</p>
<div class="math notranslate nohighlight">
\[h(x) = \sum_{i=1}^m \alpha_i^* y^{(i)} K(x^{(i)},x)+ b^*\]</div>
<p>This pulls through into the dual problem for determining <span class="math notranslate nohighlight">\(\alpha_i^*\)</span> and <span class="math notranslate nohighlight">\(b^*\)</span> such that by picking a suitable kernel function we may get close to a linearly separable transformation function without actually performing the feature mapping.</p>
</section>
</section>
<section id="recapitulation-of-svms">
<h2>Recapitulation of SVMs<a class="headerlink" href="#recapitulation-of-svms" title="Permalink to this headline">#</a></h2>
<ul class="simple">
<li><p>Problem of non-linearly separable sets</p>
<ul>
<li><p>introduction of controlled violations of the strict margin constraints</p></li>
<li><p>introduction of feature maps</p></li>
</ul>
</li>
<li><p>Controlled violation:
slack variables <span class="math notranslate nohighlight">\(\rightarrow l_1\)</span>-regularized opt. problem <span class="math notranslate nohighlight">\(\rightarrow\)</span> modified dual problem <span class="math notranslate nohighlight">\(\rightarrow\)</span> solution by SMO</p></li>
<li><p>Feature map:
kernel function (tensorial product of feature maps) <span class="math notranslate nohighlight">\(\rightarrow\)</span> reformulated dual opt. problem <span class="math notranslate nohighlight">\(\rightarrow\)</span> prediction depends only on the kernel function</p></li>
<li><p>Kernel construction:
a lot of freedom but <span class="math notranslate nohighlight">\(\rightarrow\)</span> valid kernel</p></li>
<li><p>Important kernel: Gaussian</p></li>
<li><p>Solution of non-separable problems:</p>
<ul>
<li><p>pick a suitable kernel function</p></li>
<li><p>run SVM with a kernel function</p></li>
</ul>
</li>
</ul>
</section>
<section id="further-references">
<h2>Further References<a class="headerlink" href="#further-references" title="Permalink to this headline">#</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://cs229.stanford.edu/lectures-spring2022/main_notes.pdf">CS229 Lecture Notes</a>, Chapters 5 and 6; Andrew Ng; 2022</p></li>
<li><p><a class="reference external" href="https://probml.github.io/pml-book/book1.html">Probabilistic Machine Learning: An Introduction</a>, Section 17.3; Kevin Murphy; 2022</p></li>
</ul>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./lecture"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="cc-3-classic-ml.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Core Content 3: Classic ML</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="cc-3-sub-GP.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Gaussian Processes</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By N. Adams, L. Paehler, A. Toshev<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>